/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
//#include "stm32f401xe.h"
#include "regs.h"
#include "regs_core.h"


void EXTI1_IRQHandler(void);
void delay(uint32_t d);
extern void EnableInterrupts(void);
extern void DisableInterrupts(void);
void SysTick_Handler(void);

extern void WaitForInterrupt(void);
extern void CallSVC(uint32_t);
extern void ChangeStack(void);
extern __attribute__((nacked)) void Change2MainStack(void);
extern void * Get_PSP(void);

extern void Set_PSP(uint32_t psp);


void red_on(void);
void red_off(void);
void green_on(void);
void green_off(void);

void Task_On(void);
void Task_Off(void);



#define my_irq_no 7

#define LED_Green_Pin 0
#define LED_Green_Port GPIOA

extern uint32_t _estack;
extern uint32_t _Min_Stack_Size;

uint32_t volatile tick_counter;


/* this is to easy placing things on prepared Task stacks */
struct pushed_stack_t {
	uint32_t r0;
	uint32_t r1;
	uint32_t r2;
	uint32_t r3;
	uint32_t r12;
	uint32_t lr;
	void (* pc)(void);
	uint32_t xPSR;
};

#define TASK_NO 2
#define TASK_STACK_SIZE 64

enum TASK_STATE { RUNNIG, READY };

typedef  void (* task_t)(void);

struct TCB_t {
	uint32_t psp;
	enum TASK_STATE state;
	task_t task;
	//uint32_t regs_saved_extra[8];
} volatile Task_Control[TASK_NO];

struct SCHED_t {
	uint32_t current_task;
} volatile Scheduler;

struct Stack_t {
	uint32_t e[TASK_STACK_SIZE];
} volatile Task_Stack[TASK_NO];

void Task_Config(void);
void Start_Scheduler(void);

extern void switch_task();

extern uint32_t RegsToStack(void);
extern void StackToRegs(uint32_t * sp);


void Task_Config(void) {
	uint32_t stack_size, psp;
	struct pushed_stack_t *pushed_frame;

	for (int i = 0; i < TASK_NO; ++i) {
		stack_size = sizeof (Task_Stack[0].e) / 4;
		Task_Control[i].psp = (uint32_t)(&Task_Stack[i].e + stack_size);

		/* stack pointer should be aligned to double word  */
		Task_Control[i].psp = Task_Control[i].psp & 0xFFFFfff8;
	}

	/*
	 * Calculating (lowering) start of struct - it will go then up in memmory
	 * Changing now .psp to
	 * if  .psp is pointer should subtract just 8 to accomodate 8 words
	 * but if .psp is as uint32 should subtract bytes 8 * 4 = 8 << 2
	 *
	 * Lesson1: Subtracting 7 words because .psp pointed to first free memory
	 *
	 * Lesson2: Now subtracting 8 words because if .psp was aligned to 8 bytes
	 * then after subtracting 1 as above said (in lesson 1) new stack pointer
	 * will not be aligned anymore to 8 bytes but to 4 bytes
	 *
	 */

	Task_Control[0].psp -= (8)*4;
	pushed_frame = (struct pushed_stack_t *)(Task_Control[0].psp);

 	pushed_frame->r0  = 0xAAAA0001;
	pushed_frame->r1  = 0xAAAA0002;
	pushed_frame->r2  = 0xAAAA0003;
	pushed_frame->r3  = 0xAAAA0004;
	pushed_frame->r12 = 0xAAAA0012;
	pushed_frame->lr  = 0xAAAA0013;
	pushed_frame->pc  = &Task_On;

	/*
	 * lesson: xPSR contains Thumb mode bit, which should be always set
	 * clearing it causes exeception.
	 * So as I use: pushed_frame->xPSR = 0ul;
	 * I was catching HardFault Exception.
	 * xPSR should be 0x0100 0000
	 *
	 */

	pushed_frame->xPSR = 0x01000000ul;

	Set_PSP(Task_Control[0].psp);
	//psp = RegsToStack();
	//Task_Control[0].psp = psp;


	Task_Control[1].psp -= (8)*4;
	pushed_frame = (struct pushed_stack_t *)(Task_Control[1].psp);
	pushed_frame->pc = &Task_Off;
	pushed_frame->xPSR = 0ul;
	//Set_PSP(Task_Control[1].psp);
	//psp = RegsToStack();
	//Task_Control[1].psp = psp;

	Set_PSP(Task_Control[0].psp);
	Scheduler.current_task = 0ul;

}

void SelectNextTask(void) {
	++Scheduler.current_task;
	Scheduler.current_task %= TASK_NO;
}

void StartScheduler(void) {

	SelectNextTask();

}



int main(void)
{
    /* Loop forever */
	uint32_t val;

	tick_counter = 0ul;

	//NVIC->ISER[0] = 1 << 31;
	//NVIC->ICER[0] = 1 << 31;
	//DisableInterrupts();

	/* configure port and pins */
	RCC->AHB1ENR = (uint32_t) 1;

	val = GPIOA->MODER;
	val = val | (uint32_t)1;
	val = val | (uint32_t)1 << 4;
	GPIOA->MODER = val;

	val = GPIOA->OSPEEDR;
	val = val | 2 | ( 2 << 4);
	GPIOA->OSPEEDR = val;


	/* configure periphery interrupts */
	EXTI->IMR |= 2UL;
	EXTI->RTSR |= 2UL;
	SYSCFG->EXTICR[0] &= ~( 0xFUL << 4 );

	/* configure SysTICK */
	STK->VAL  = 0ul;
	STK->LOAD = 0x00FFFFFFul;
	val  = 0;
	val  = 1; /* bit 0 - enable systick */
	val |= ( 1 << 1 ); /* bit 1 - enable exeption on couting to zero */
	val |= ( 1 << 2 ); /* bit 2 = 1  choses processor clock as source */
	STK->CTRL = val;

	/* configure core interrupts */

	NVIC->ISER[0] = 1 << my_irq_no; // Enabling this EXTERNAL interrupt
	EnableInterrupts();

	Task_Config();
	ChangeStack();
	CallSVC(Task_Control[0].psp);


	Change2MainStack();

	while (1) {

		val = 1 << (16+2);

	}
}

void EXTI1_IRQHandler(void) {
	uint32_t val;
	struct poped_stack_t * ps;

	//stack_marker(0xa0a0a0a0, 0xe0e0e0e0);

	ps = Get_PSP();

	val = GPIOA->ODR;
	if ( val & 4ul ) {
		//GPIOA->BSRR = 1ul << (16+2);
		//red_off();
	} else {
		//GPIOA->BSRR = 1ul << 2;
		//red_on();
	}

	//GPIOA->BSRR = 1 << 2;
	val = (2UL);
	EXTI->PR |= val;  // clear pending interrupt by setting this bit to 1
	//GPIOA->BSRR = 1 << (16+2) | 1;
	//delay(100);
	//GPIOA->BSRR = 1 << 2;
	//delay(1);
	return;
}

void SysTick_Handler(void) {
	uint32_t volatile val;

	val = GPIOA->ODR;
	if ( val & 1ul ) {
		//GPIOA->BSRR = 1ul << 16;
		green_off();
	} else {
		//GPIOA->BSRR = 1ul;
		green_on();
	}

	++tick_counter;
	return;
}

void Task_On(void) {
	volatile uint32_t D;
	D = 0x3000;
	while(1) {
		red_on();
		delay(10000);
		++D;
	}
}

void Task_Off(void) {
	volatile uint32_t D;
	D = 0x2000;
	while (1) {
		red_off();
		delay(10000);
		++D;
	}
}


void red_on(void) {
	GPIOA->BSRR = 1ul << 2;
}
void red_off(void) {
	GPIOA->BSRR = 1ul << (16+2);
}

void green_on(void) {
	GPIOA->BSRR = 1ul;
}
void green_off(void) {
	GPIOA->BSRR = 1ul << 16;
}

void delay(uint32_t d) {
	uint32_t volatile x;
	for (; d > 0; --d) {
		x = d;
	}
}
