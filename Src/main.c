/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
//#include "stm32f401xe.h"
#include "regs.h"
#include "regs_core.h"

void EXTI1_IRQHandler(void);
void delay(uint32_t d);
extern void EnableInterrupts(void);
extern void DisableInterrupts(void);
void SysTick_Handler(void);

extern void WaitForInterrupt(void);
extern void CallSVC(void);
extern void ChangeStack(void);
extern __attribute__((nacked)) void Change2MainStack(void);
extern void * Get_psp_addr(void);


void red_on(void);
void red_off(void);
void green_on(void);
void green_off(void);

void Task_On(void);
void Task_Off(void);



#define my_irq_no 7

#define LED_Green_Pin 0
#define LED_Green_Port GPIOA

extern uint32_t _estack;
extern uint32_t _Min_Stack_Size;

uint32_t volatile tick_counter;

struct pushed_stack_t {
	uint32_t r0;
	uint32_t r1;
	uint32_t r2;
	uint32_t r3;
	uint32_t r12;
	uint32_t lr;
	void (* pc)(void);
	//uint32_t pc;
	uint32_t xPSR;
};

#define TASK_NO 2
#define TASK_STACK_SIZE 128

typedef  void (* task_t)(void);

struct TCB_t {
	uint32_t *psp;
	uint32_t stack_size;
	//void (* task)(void);
	task_t task;
	uint32_t regs_saved_extra[8];
} volatile Task_Control[TASK_NO];

struct SCHED_t {
	uint32_t current_task;
} volatile Scheduler;

struct Stack_t {
	uint32_t e[TASK_STACK_SIZE];
} volatile Task_Stack[TASK_NO];

void Task_Config(void);
void Start_Scheduler(void);

extern void switch_task();


void Task_Config(void) {
	uint32_t stack_size;
	Scheduler.current_task = 0ul;
	struct pushed_stack_t *pushed_frame;

	for (int i = 0; i < TASK_NO; ++i) {
		stack_size = sizeof (Task_Stack[0].e) / 4;
		Task_Control[i].psp = Task_Stack[i].e + stack_size;

		/* stack pointer should be aligned to double word  */
		Task_Control[i].psp = (uint32_t *)((uint32_t)Task_Control[i].psp & 0xFFFFfff8);
		//uint32_t m;
		//m = (uint32_t)Task_Control[i].psp & 0x0000000F;
		/*if ( (m != 0) || (m != 8)  ) {   Stack unalignend to 8 byte
			if ( m < 8 ) {
				Task_Control[i].psp = (uint32_t *)(((uint32_t)Task_Control[i].psp & 0xFFFFfff8) - 0x8ul);
			} else {
				Task_Control[i].psp = (uint32_t *)(((uint32_t)Task_Control[i].psp & 0xFFFFfff) - 0xFul);
			}
		}*/
	}

	pushed_frame = (struct pushed_stack_t *)(Task_Control[0].psp - 8);
	pushed_frame->r0  = 0xAAAA0001;
	pushed_frame->r1  = 0xAAAA0002;
	pushed_frame->r2  = 0xAAAA0003;
	pushed_frame->r3  = 0xAAAA0004;
	pushed_frame->r12 = 0xAAAA0012;
	pushed_frame->lr  = 0xFFFFfffd;
	pushed_frame->pc  = &Task_On;
	pushed_frame->xPSR = 0ul;

	pushed_frame = (struct pushed_stack_t *)(Task_Control[1].psp - 8);
	pushed_frame->r0 = 0xBBBB0001;
	pushed_frame->pc = &Task_Off;
	pushed_frame->xPSR = 0ul;

	Task_Control[0].task = &Task_On;
	Task_Control[1].task = &Task_Off;


	for (int i = 0; i < 0 && i < TASK_NO; ++i) {

		--Task_Control[i].psp;
		*((uint32_t *)Task_Control[0].psp) = 0; /* PSR */

		// return address = PC meas starting addr of task
		--Task_Control[i].psp;
		*(Task_Control[i].psp) = (uint32_t)Task_Control[i].task;
		//(task_t *)Task_Control[i].psp = Task_Control[i].task;
				/* LR, r12, and r0 - r3 */
		for (int j = 0; j < 6; ++j) {
			--Task_Control[i].psp;
			*((uint32_t *)Task_Control[i].psp) = i*16 + j;
		}
	}


}

void Start_Scheduler(void) {
	uint32_t k;
	++Scheduler.current_task;
	Scheduler.current_task %= TASK_NO;

	k = Scheduler.current_task;

}


extern void RegsToStack(void);
extern void StackToRegs(void);

int main(void)
{
    /* Loop forever */
	uint32_t val;


	Task_Config();

	tick_counter = 0ul;

	//NVIC->ISER[0] = 1 << 31;
	//NVIC->ICER[0] = 1 << 31;
	//DisableInterrupts();

	/* configure port and pins */
	RCC->AHB1ENR = (uint32_t) 1;

	val = GPIOA->MODER;
	val = val | (uint32_t)1;
	val = val | (uint32_t)1 << 4;
	GPIOA->MODER = val;

	val = GPIOA->OSPEEDR;
	val = val | 2 | ( 2 << 4);
	GPIOA->OSPEEDR = val;


	/* configure periphery interrupts */
	EXTI->IMR |= 2UL;
	EXTI->RTSR |= 2UL;
	SYSCFG->EXTICR[0] &= ~( 0xFUL << 4 );

	/* configure SysTICK */
	STK->VAL  = 0ul;
	STK->LOAD = 0x00FFFFFFul;
	val  = 0;
	val  = 1; /* bit 0 - enable systick */
	val |= ( 1 << 1 ); /* bit 1 - enable exeption on couting to zero */
	val |= ( 1 << 2 ); /* bit 2 = 1  choses processor clock as source */
	STK->CTRL = val;

	/* configure core interrupts */

	NVIC->ISER[0] = 1 << my_irq_no; // Enabling this EXTERNAL interrupt
	EnableInterrupts();

	ChangeStack();

	Change2MainStack();

	while (1) {

		val = 1 << (16+2);

	}
}

void EXTI1_IRQHandler(void) {
	uint32_t val;
	struct poped_stack_t * ps;

	//stack_marker(0xa0a0a0a0, 0xe0e0e0e0);

	ps = Get_psp_addr();

	val = GPIOA->ODR;
	if ( val & 4ul ) {
		//GPIOA->BSRR = 1ul << (16+2);
		//red_off();
	} else {
		//GPIOA->BSRR = 1ul << 2;
		//red_on();
	}

	//GPIOA->BSRR = 1 << 2;
	val = (2UL);
	EXTI->PR |= val;  // clear pending interrupt by setting this bit to 1
	//GPIOA->BSRR = 1 << (16+2) | 1;
	//delay(100);
	//GPIOA->BSRR = 1 << 2;
	//delay(1);
	return;
}

void SysTick_Handler(void) {
	uint32_t volatile val;

	val = GPIOA->ODR;
	if ( val & 1ul ) {
		//GPIOA->BSRR = 1ul << 16;
		green_off();
	} else {
		//GPIOA->BSRR = 1ul;
		green_on();
	}

	++tick_counter;
	return;
}

void Task_On(void) {
	volatile uint32_t D;
	D = 0x3000;
	while(1) {
		red_on();
		delay(10000);
		++D;
	}
}

void Task_Off(void) {
	volatile uint32_t D;
	D = 0x2000;
	while (1) {
		red_off();
		delay(10000);
		++D;
	}
}


void red_on(void) {
	GPIOA->BSRR = 1ul << 2;
}
void red_off(void) {
	GPIOA->BSRR = 1ul << (16+2);
}

void green_on(void) {
	GPIOA->BSRR = 1ul;
}
void green_off(void) {
	GPIOA->BSRR = 1ul << 16;
}

void delay(uint32_t d) {
	uint32_t volatile x;
	for (; d > 0; --d) {
		x = d;
	}
}
